import { GoogleGenerativeAI } from '@google/generative-ai'
import dotenv from 'dotenv'
dotenv.config({ quiet: true })
const GEMINI_API_KEY = process.env.GEMINI_API_KEY
const GEMINI_MODEL = 'gemini-2.5-flash-image'
const USE_MOCK = process.env.USE_MOCK_GEMINI === 'true'

// Initialize Google Generative AI client
let genAI = null
let model = null

const initializeGemini = () => {
  if (!genAI && GEMINI_API_KEY && !USE_MOCK) {
    genAI = new GoogleGenerativeAI(GEMINI_API_KEY)
    model = genAI.getGenerativeModel({ model: GEMINI_MODEL })
  }
}

/**
 * Generate images using Gemini 2.5 Flash Image with aspect ratio support
 * @param {string} prompt - Text prompt describing the desired image
 * @param {Array} referenceImages - Optional array of base64 encoded images
 * @param {string} aspectRatio - Aspect ratio (e.g., '16:9', '1:1', '4:3')
 * @returns {Promise<Object>} Generated image data
 */
export const generateImage = async (
  prompt,
  referenceImages = [],
  aspectRatio = '1:1'
) => {
  try {
    // Mock response for testing without API quota
    if (USE_MOCK) {
      console.log('Using mock Gemini response')
      const mockImageBase64 = generateMockImage(prompt, aspectRatio)
      return {
        images: [
          {
            data: mockImageBase64,
            mimeType: 'image/svg+xml',
          },
        ],
        text: `Mock moodboard generated for: ${prompt}`,
      }
    }

    // Validate API key
    if (!GEMINI_API_KEY) {
      throw new Error('GEMINI_API_KEY is not defined in environment variables')
    }

    // Initialize Gemini client if not already done
    initializeGemini()

    // Build content with configuration for aspect ratio
    const generationConfig = {
      temperature: 1,
      topP: 0.95,
      topK: 64,
      maxOutputTokens: 8192,
      responseMimeType: 'application/json',
    }

    // Add image generation configuration
    const imageConfig = {
      aspectRatio: aspectRatio,
      responseModalities: ['image'],
    }

    // Build content parts
    const parts = [
      {
        text: `Generate an interior design moodboard image with aspect ratio ${aspectRatio}. ${prompt}`,
      },
    ]

    // Add reference images if provided
    if (referenceImages && referenceImages.length > 0) {
      referenceImages.forEach((imageData) => {
        parts.push({
          inlineData: {
            mimeType: imageData.mimeType || 'image/png',
            data: imageData.data,
          },
        })
      })
    }

    console.log(
      `Generating with Gemini 2.5 Flash Image (aspect ratio: ${aspectRatio})...`
    )

    // Generate content using official SDK
    const result = await model.generateContent({
      contents: [{ role: 'user', parts }],
      generationConfig,
      ...imageConfig,
    })

    const response = result.response

    // Extract images and text from response
    const images = []
    let text = null

    const candidates = response.candidates || []
    if (candidates.length === 0) {
      throw new Error('No candidates returned from Gemini API')
    }

    const candidate = candidates[0]
    const contentParts = candidate.content?.parts || []

    for (const part of contentParts) {
      if (part.text) {
        text = part.text
      } else if (part.inlineData) {
        images.push({
          data: part.inlineData.data,
          mimeType: part.inlineData.mimeType || 'image/png',
        })
      }
    }

    if (images.length === 0) {
      throw new Error('No image generated by Gemini')
    }

    console.log(
      `Successfully generated ${images.length} image(s) with aspect ratio ${aspectRatio}`
    )

    return { images, text }
  } catch (error) {
    console.error('Gemini API Error:', error)

    // Handle specific error types
    if (error.message?.includes('quota')) {
      throw new Error(
        'Gemini API quota exceeded. Please enable billing at https://aistudio.google.com/ or set USE_MOCK_GEMINI=true in .env for testing.'
      )
    }

    if (error.message?.includes('API key')) {
      throw new Error(
        'Invalid Gemini API key. Please check your GEMINI_API_KEY in .env file.'
      )
    }

    throw new Error(`Failed to generate image: ${error.message}`)
  }
}

/**
 * Generate a mock image for testing with aspect ratio support
 */
const generateMockImage = (prompt, aspectRatio = '1:1') => {
  // Parse aspect ratio
  const [widthRatio, heightRatio] = aspectRatio.split(':').map(Number)
  const width = 1200
  const height = Math.round(width * (heightRatio / widthRatio))

  // Escape XML special characters in prompt
  const safePrompt = prompt
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .substring(0, 60)

  // Create a simple SVG with the specified aspect ratio
  const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#947d61;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#a68970;stop-opacity:1" />
    </linearGradient>
  </defs>
  <rect width="${width}" height="${height}" fill="url(#grad)"/>
  
  <!-- Mock Moodboard Grid -->
  <rect x="50" y="50" width="${Math.round(width / 3.5)}" height="${Math.round(
    height / 2.5
  )}" fill="rgba(255,255,255,0.1)" rx="10"/>
  <rect x="${Math.round(width / 2.5)}" y="50" width="${Math.round(
    width / 3.5
  )}" height="${Math.round(
    height / 2.5
  )}" fill="rgba(255,255,255,0.1)" rx="10"/>
  
  <!-- Title -->
  <text x="${
    width / 2
  }" y="100" font-family="Arial, sans-serif" font-size="32" font-weight="bold" fill="white" text-anchor="middle">
    MOCK MOODBOARD (${aspectRatio})
  </text>
  
  <!-- Info -->
  <text x="${
    width / 2
  }" y="150" font-family="Arial, sans-serif" font-size="18" fill="rgba(255,255,255,0.9)" text-anchor="middle">
    Enable billing at https://aistudio.google.com for real AI generation
  </text>
  
  <!-- Prompt -->
  <text x="${width / 2}" y="${
    height - 50
  }" font-family="Arial, sans-serif" font-size="16" fill="rgba(255,255,255,0.7)" text-anchor="middle">
    ${safePrompt}...
  </text>
</svg>`

  return Buffer.from(svg).toString('base64')
}

/**
 * Edit an existing image using Gemini's targeted transformation
 * @param {string} prompt - Edit instruction
 * @param {string} imageData - Base64 encoded image to edit
 * @param {string} mimeType - Image MIME type
 * @param {string} aspectRatio - Aspect ratio for the edited image
 * @returns {Promise<Object>} Edited image data
 */
export const editImage = async (
  prompt,
  imageData,
  mimeType = 'image/png',
  aspectRatio = '1:1'
) => {
  try {
    // Use Gemini's targeted transformation capabilities
    const editPrompt = `Apply the following targeted transformation to this image: ${prompt}. Maintain the composition while making only the requested changes. Keep aspect ratio ${aspectRatio}.`

    return await generateImage(
      editPrompt,
      [{ data: imageData, mimeType }],
      aspectRatio
    )
  } catch (error) {
    console.error('Image editing error:', error.message)
    throw error
  }
}

/**
 * Regenerate specific images with variations
 * @param {Array} imageIndices - Indices of images to regenerate
 * @param {string} basePrompt - Base prompt for regeneration
 * @param {string} customPrompt - Additional custom requirements
 * @param {string} aspectRatio - Aspect ratio for regenerated images
 * @returns {Promise<Array>} Array of regenerated images
 */
export const regenerateImages = async (
  imageIndices,
  basePrompt,
  customPrompt = '',
  aspectRatio = '1:1'
) => {
  try {
    const regeneratedImages = []

    for (const index of imageIndices) {
      const variationPrompt = customPrompt
        ? `${basePrompt}. Additional: ${customPrompt}. Create variation ${
            index + 1
          }.`
        : `${basePrompt}. Create variation ${index + 1}.`

      const result = await generateImage(variationPrompt, [], aspectRatio)
      regeneratedImages.push({ index, ...result.images[0] })
    }

    return regeneratedImages
  } catch (error) {
    console.error('Image regeneration error:', error.message)
    throw error
  }
}

/**
 * Build an enhanced moodboard prompt based on user preferences
 * @param {Object} options - Moodboard generation options
 * @returns {string} Enhanced prompt
 */
export const buildMoodboardPrompt = ({
  style,
  roomType,
  colorPalette,
  customPrompt,
  layout,
  aspectRatio,
}) => {
  let prompt = ''

  // Add style information
  if (style && style !== 'custom') {
    prompt += `Create a ${style} style interior design moodboard`
  } else {
    prompt += 'Create an interior design moodboard'
  }

  // Add room type
  if (roomType) {
    const formattedRoomType = roomType.replace(/_/g, ' ')
    prompt += ` for a ${formattedRoomType}`
  }

  // Add color palette
  if (colorPalette && colorPalette.length > 0) {
    prompt += `. Use a color palette featuring ${colorPalette.join(', ')}`
  }

  // Add layout information
  if (layout) {
    const layoutDescriptions = {
      grid: 'arranged in a clean grid layout',
      collage: 'in an artistic collage style with varied sizes',
      single: 'as a single comprehensive design',
    }
    prompt += `, ${layoutDescriptions[layout] || 'in a professional layout'}`
  }

  // Add aspect ratio if specified
  if (aspectRatio && aspectRatio !== '1:1') {
    prompt += `. Optimize composition for ${aspectRatio} aspect ratio`
  }

  // Add custom prompt if provided
  if (customPrompt) {
    prompt += `. ${customPrompt}`
  }

  // Add professional photography details
  prompt += `. Professional interior design presentation with high-quality materials, textures, and lighting. Photorealistic rendering with attention to detail.`

  return prompt.trim()
}
